---
title: 浏览器缓存机制小结
date: 2017-03-8 12:18:25
tags:
---

浏览器缓存是前端开发中不可避免的问题，对于web应用来说，它是提升页面性能同时减少服务器压力的利器。本文将简单地描述总结下浏览器缓存的知识和应用，希望对自己和大家都有所帮助

## 查看chrome缓存
我们先在chrome浏览器下看看到底缓存了什么东西
输入chrome://view-http-cache/，可以看到chrome所有的缓存文件
![image](https://cloud.githubusercontent.com/assets/14155079/25742517/64009b6e-31c2-11e7-85a6-4ee9c3daa031.png)
随便点开一个，可以看到这个缓存文件所有的信息，包括访问url，http请求的头信息，和缓存文件正文内容
![image](https://cloud.githubusercontent.com/assets/14155079/25742554/904bc054-31c2-11e7-9856-75b72e26ba95.png)
这样看是不是对浏览器的缓存有了一个更具体的认识了呢~接下来，来讲解浏览器怎样利用这些缓存来提升网站性能的。


## 浏览器缓存类型
有两种，**强缓存**和**协商缓存**
1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示**from disk cache**或**from memory cache**；

2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

3.两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求
## 缓存有关的header
### 强缓存
`Expires`：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。

`Cache-Control`：当值设为`max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

![image](https://cloud.githubusercontent.com/assets/14155079/23694975/d5b4a4d6-0417-11e7-92e0-5783dbd4b910.png)
![image](https://cloud.githubusercontent.com/assets/14155079/23695143/b464c0ee-0418-11e7-93d6-ed81800d2351.png)

>Expires和Cache-Control:max-age=*** 的作用是差不多的，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法

### 协商缓存
`ETag`和`If-None-Match`：这两个要一起说。Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。

`Last-Modified`和`If-Modified-Since`：这两个也要一起说。Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。

*response header*
![image](https://cloud.githubusercontent.com/assets/14155079/23696499/e4cbda50-041e-11e7-8398-def44064aa5c.png)

*request header*
![image](https://cloud.githubusercontent.com/assets/14155079/23696518/f7ca722e-041e-11e7-9c5b-fce1fe77d30e.png)


>ETag和Last-Modified的作用和用法也是差不多，说一说他们的区别。
首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。

>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。

>第三在优先级上，服务器校验优先考虑Etag。

## 浏览器缓存过程
1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；

3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；

4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

## 用户行为对浏览器缓存的控制

1. 地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；

2. F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；

3. ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。

